---
title: "Letâ€™s build a database"
author: "Thomas Van Hoey"
date: "19/9/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Goals
What I want to do is combine three documents together:
1. My own database project (.odb)
2. Kroll's (2015) A-M (by Arthur)
3. Kroll's (2015) N-Z (by Thomas)

# Before programming intervenes

* Add 'neglected' entries from dictionary
* Make sure source files are correct (first skype)

# Package load
```{r}
library(tidyverse)
library(ODB)
library(tmcn)
library(pinyin)
```


# The .odb database

## Getting the R-object and wrangling

First we need to make a connection with the database, get everything out of it, and turn it into an R-object (tibble/dataframe).

```{r}
db <- odb.open("ideophone.odb")
#db
#names <- names(odb.tables(db))
#tables <- odb.tables(db)
#names
#tables
SQL <- 'SELECT * FROM "ideophone"' #use single and double quotes, quotes around table name
database <- odb.read(db, SQL)
#print(database)
database
```

We are leaving out:
- Zdic
- Ricci
- same_as_ID
- form_letterID
- form_mechanismID


```{r}
#colnames(database)

DBwr <- database %>%
  select(pinyin, pinyintone, traditional, simplified, MC, OC, Kroll, note)
DBwr
```

# Kroll A-M

## Getting R-object

```{r}
Kroll_ar <- readxl::read_excel("kroll_Arthur.xlsx")
Kroll_ar

colnames(Kroll_ar)

KAwr <- Kroll_ar %>%
  rename(traditional = `Kroll Binome`,
         pinyinnum = pinyin,
         Kroll = English,
         notes = Notes,
         radsup = `Radical Support`) %>%
  select(traditional,
         pinyinnum,
         MC,
         Kroll,
         `Morphological Structure`,
         radsup,
         notes)
KAwr
```


# Kroll N-Z

## Getting R-object
```{r}
Kroll_th <- readxl::read_excel("kroll_Thomas.xlsx")
Kroll_th

colnames(Kroll_th)

KTwr <- Kroll_th %>%
  rename(traditional = `Kroll Binome`,
         pinyinnum = pinyin,
         Kroll = English,
         notes = Notes,
         radsup = `Radical Support`) %>%
  select(traditional,
         pinyinnum,
         MC,
         Kroll,
         `Morphological Structure`,
         radsup,
         notes)
KTwr
```

This leaves out:
- page no
- variant

# Combining the tables

```{r}
#DBh <- head(DBwr)
#KTh <- head(KTwr)
#KAh <- head(KAwr)

#colnames(DBh)
#colnames(KTh)
#colnames(KAh)
```

```{r}
joined1 <- full_join(DBwr, KTwr, by = c("traditional", "Kroll", "MC", "note" = "notes"))
joined <- full_join(joined1, KAwr, by = c("traditional", "Kroll", "MC", "note" = "notes", "pinyinnum", "radsup", "Morphological Structure"))
joined
```

# Revamping stuff

## Simplified

Obviously, there are going to be mistakes here.
```{r}
# from trad to simpl
joined <- joined %>%
  mutate(simplified = toTrad(traditional, rev=TRUE)) 
```

## Pinyin

After some testing, it seemed that neither `pinyin` or `tmcn` could bring what I wanted: pinyin without tones, pinyin with tone, pinyin with tone numbers. Thus we need to do this manually?
It seems python can come to the rescue.

Maybe if we split the characters and then combine them again?

```{r}
list <- joined %>%
  select(traditional) %>%
  unlist()
```

```{r}
library(reticulate)
use_python("/usr/local/bin/python3", required = T)
reticulate::py_config()
```

```{python}
import pinyin
a = r.list

richard = []
for i in a:
    richard.append(i)

thomas = []
for i in a:
    j = pinyin.get(i, delimiter="~")
    thomas.append(j)
    
cj = []
for i in a:
    j = pinyin.get(i, format= "strip", delimiter="~")
    cj.append(j)
    
arthur = []
for i in a:
    j = pinyin.get(i, format="numerical", delimiter="~")
    arthur.append(j)
#print (thomas)
#print(type(thomas))
```

```{r}
#py_run_file("script.py")
#py_run_string("x = 10")

# access the python main module via the 'py' object
#py$x
thomas <- py$thomas #%>% tibble()
thomas <- tibble(thomas)

cj <- py$cj #%>% tibble()
cj <- tibble(cj)

arthur <- py$arthur #%>% tibble()
arthur <- tibble(arthur)

thomas
cj
arthur
```

# zdic entries

## set up
```{r}
library(rvest)
```

```{r opzoeken.function}
opzoeken <- function(query){
  # Specify URL
  url <- "http://wap.zdic.net/"
  session <- html_session(url)

  # Grab Initial Form
  #  Form is filled in stages. Here, only do country and date
  form.unfilled <- 
    session %>% 
    html_node("form") %>% 
    html_form()

  form.filled <- 
    form.unfilled %>%
    set_values("q" = query)

  # submit the form and save as a new session
  submitted <- submit_form(session, form.filled) 

  # look for a definition in the nodes
  definitie <- 
    submitted %>% 
    html_nodes(xpath = "/html/body/div/div[1]/div/ol/div/li/p[1]") %>%
    html_text()
  
  if (is_empty(definitie) == TRUE){
    definitie <- "NA"
  } else {
    definitie <- definitie
  }

  pronunciation <-
    submitted %>%
    html_nodes(xpath = "//rtc//rt") %>%
    html_text()

  pinyin <- pronunciation[1]
  zhuyin <- pronunciation[2]

  df <- data.frame(
    woord = query,
    pinyin = pinyin,
    zhuyin = zhuyin,
    definitie = definitie %>%
      paste(collapse = "")
  )
}

opzoeken <- possibly(opzoeken, otherwise = NA_real_)
```


With the head() this worked, so probably with all the rest too.

```{r}
list2 <- py$richard %>% head()
#list2
map_df(list2, opzoeken) %>%
  select(woord, definitie)
```


# Distinct entries

I don't know if I should run this, this may best be done manually?

```{r}
#joined %>%
#  distinct()
#unique(joined$`Morphological Structure`)
#joined %>%
#filter(`Morphological Structure` == "NOTIDEOPHONE")
```

# Finishing touches
## Put all extra tables together
```{r}

```

## Sort the final table
```{r}

```

## Sort the variables in final table
```{r}

```



# Stuff that needs to happen after coding.

## Higher priorities

* Manually checking all three new pronunciations agains the old ones. The old ones were only partially filled out, but they were correct. With computing it is possible to fill out the whole table but it might be wrong.
* Checking traditional vs. simplified characters.
* Fill out radsup
* Fill out MC

## Lower priorites

* Fill out OC











